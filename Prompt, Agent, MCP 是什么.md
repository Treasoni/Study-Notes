
# Prompt（提示词）

> 🎯 **写信比喻**
>
> 用 AI 就像写信给一个人：
> - **User Prompt** = 你每次写的内容
> - **System Prompt** = 收信人的「设定」（比如：「你是医生」）
>
> 有了设定，对方就会用医生的专业身份回答你！

## 1. User Prompt（用户提示词）

在 AI 刚兴起的时候（如 OpenAI 发布 GPT），AI 就像一个聊天框。我们通过聊天框给 AI 模型发送消息，AI 模型会自动生成一个回复。这里我们给 AI 模型发送的信息就是 **用户提示词（User Prompt）**。

## 2. System Prompt（系统提示词）

但是单纯的聊天模式下，AI 只能给出通用的回答。如果我们想要 AI 具有特定人设，可以在消息中指定，比如：「你是我的女朋友，我的肚子痛。」

这样 AI 就会从「女朋友」的角度来回复消息，实现不同人设做出不同回答。但每次都要在用户消息中写人设很不方便，于是出现了 **系统提示词（System Prompt）**。

> **比喻**：就像给演员设定角色——「你演医生」、「你演老师」。
> 演员记住角色后，之后的每一句话都符合这个人设。

![](assets/Prompt,%20Agent,%20MCP%20是什么/file-20260205124233782.png)

System Prompt 用于预先设置人设、角色、行为准则等信息。之后每次发送 User Prompt 时，会自动把 System Prompt 一起发给 AI 模型。

### Prompt 的角色分工

| 类型 | 作用 | 位置 | 比喻 | 示例 |
|------|------|------|------|------|
| **System Prompt** | 定义角色、人设、行为准则 | 最先发送 | 演员的角色卡 | 「你是一个专业的程序员助手」 |
| **User Prompt** | 用户的实际输入 | 中间发送 | 观众的问题 | 「帮我写一个快速排序」 |
| **Assistant Message** | AI 的回复 | 最后返回 | 演员的台词 | AI 生成的回答内容 |


# Agent（智能体）

> 🎯 **全能管家比喻**
>
> AI 原本只能聊天（像普通管家）。
> Agent 让 AI 学会了动手干活（像全能管家）：
> - 需要天气？Agent 调用天气工具
> - 需要查资料？Agent 调用搜索工具
> - 需要写文件？Agent 调用文件工具
>
> 从「只会说」变成「能说能做」！

## 1. 为什么需要 Agent？

按照上面的模型，AI 可以根据不同的人设做出不同的回答。但我们不想只把 AI 当成一个聊天工具，而是希望它能够实现具体功能、执行操作。

因此就出现了 **Agent（智能体）**。

## 2. Agent 的工作原理

Agent 的核心是 **Tools（工具）**——一些可以被调用的函数。这些函数把自己的功能名称、描述、参数格式等信息注册到 Agent 中。

> **比喻**：就像一个工具箱，每个工具都有自己的说明书。
> Agent 就像一个熟练的工人，知道什么时候该用什么工具。

Agent 的工作流程：

```
┌─────────────────────────────────────────────────────────────────┐
│  1. Agent 收集所有 Tools 的信息（名称、功能、参数格式）           │
│  2. Agent 将这些信息构造成 System Prompt，告诉 AI 有哪些工具可用  │
│  3. Agent 发送 System Prompt + User Prompt 给 AI 模型             │
│  4. AI 决定是否需要调用工具，返回调用请求                          │
│  5. Agent 接收请求，执行对应的 Tool 函数                           │
│  6. Tool 执行完将结果返回给 Agent                                 │
│  7. Agent 将结果发送给 AI，AI 基于结果继续生成内容                 │
│  8. 如果还需要调用工具，重复 4-7 步，否则返回最终答案给用户        │
└─────────────────────────────────────────────────────────────────┘
```
![](assets/Prompt,%20Agent,%20MCP%20是什么/file-20260205124252571.png)
## 3. Agent 的关键组件

| 组件 | 作用 | 比喻 |
|------|------|------|
| **Agent Framework** | Agent 框架，协调 AI 和工具之间的交互 | 建筑公司的项目经理 |
| **Tools** | 可被调用的函数，提供具体功能（如天气查询、文件操作等） | 专业的工人师傅（电工、木工等） |
| **Tool Registry** | 工具注册表，存储所有工具的元信息 | 工人通讯录（知道每个工人会什么） |
| **AI Model** | 大语言模型，负责理解意图和决策 | 总工程师（规划怎么做） |

# Function Calling（函数调用）

> 🎯 **填表比喻**
>
> - **自然语言方式** = 让 AI 填写「请写一份报告」，格式不固定
> - **Function Calling** = 给 AI 一张固定格式的表单：「姓名：[ ] 电话：[ ]」
>
> 有了表单，AI 知道确切要填什么！

## 1. 为什么需要 Function Calling？

在早期的 Agent 实现中，Agent 通过自然语言（大白话）告诉 AI 模型应该如何使用工具、返回什么格式。但 AI 是一个概率模型，输出可能不稳定，有时返回正确的调用格式，有时则不会。为了保证可靠性，可能需要多次尝试或重试。

> **比喻**：就像让 AI 「说一个电话号码」，它可能说「我的电话是 12345678」，
> 也可能说「电话：12345678」，甚至可能不按格式说。
> Function Calling 就像给出一张表单，AI 必须按固定格式填写。

为了解决这个问题，出现了 **Function Calling（函数调用）**——一种标准化的工具调用机制。

## 2. Function Calling 的改进

| 方式 | 描述格式 | 稳定性 | 比喻 |
|------|----------|--------|------|
| **自然语言描述** | 用文字描述工具和返回格式 | 不稳定，AI 可能不遵循格式 | 口头传达任务 |
| **Function Calling** | 用 JSON Schema 规范描述工具 | 稳定，强制格式约束 | 填写标准表单 |

Function Calling 的核心改进：

1. **工具描述标准化**：每个 Tool 用 JSON Schema 对象进行描述
2. **调用格式标准化**：规定了 AI 使用工具时应返回的固定格式
3. **返回值类型约束**：明确定义参数类型（string、number、array 等）

> **比喻**：
> - 没有约束 = 「说一个数字」→ AI 可能说「三」，也可能说「3」，也可能说「03」
> - 有类型约束 = 「说一个整数」→ AI 必须返回 `3`

### Function Calling 的工具描述示例

```json
{
  "type": "function",
  "function": {
    "name": "get_weather",
    "description": "获取指定城市的天气信息",
    "parameters": {
      "type": "object",
      "properties": {
        "city": {
          "type": "string",
          "description": "城市名称"
        }
      },
      "required": ["city"]
    }
  }
}
```

## 3. 目前的现状

Function Calling 原本是一个通用概念，但不同大模型厂商的实现方式不同（OpenAI、Anthropic、Google 等的 API 格式都不完全一致）。

> **比喻**：就像不同品牌的充电头——
> - iPhone 用 Lightning 接口
> - Android 用 USB-C 接口
> - 功能都一样（充电），但形状不同

因此目前实践中：
- **标准 Function Calling**：用于主流 AI 厂商的专用格式
- **System Prompt 方式**：用于兼容性或特殊场景
- 两种方式根据具体需求选择使用


# MCP（Model Context Protocol，模型上下文协议）

> 🎯 **USB 接口比喻**
>
> 在 MCP 出现之前，每个工具都有自己的接口：
> - 天气工具用「天气接口」
> - 文件工具用「文件接口」
> - 搜索工具用「搜索接口」
>
> 就像每个设备都需要专用插头，换个设备就得换个插座！
>
> MCP 就像 **USB**——一个通用标准，所有设备都能用同一个接口！

## 1. 为什么需要 MCP？

上面讨论的都是 Agent 与 AI 大模型之间的交互方式。但是 Agent 如何与 Tools 通信呢？

每个开发者可能用不同的方式实现 Tools：
- 不同的接口格式
- 不同的通信方式
- 不同的参数定义

> **比喻**：就像每个厨师都说自己的方言——
> - 张厨师说：「炒！放盐！」
> - 李厨师说：「加温！加盐！」
> - 王厨师说：「起锅！放盐！」
>
> 他们听不懂彼此，无法协同工作！

这导致不同 Agent 之间很难共享工具。

为了解决这个问题，出现了 **MCP（Model Context Protocol，模型上下文协议）**。

## 2. MCP 的角色

| 原有概念 | MCP 概念 | 比喻 |
|----------|----------|------|
| Agent Tools | **MCP Server** | 专业服务店 |
| Agent | **MCP Client** | 需要服务的客户 |

## 3. MCP 协议规范

MCP 规定了 MCP Server 和 MCP Client 之间的通信标准：

> **比喻**：就像外卖平台的统一标准——
> - 所有餐厅都必须用统一的菜单格式
> - 所有骑手都用统一的取餐码
> - 客户不管从哪家点餐，操作流程都一样

### 3.1 通信方式

MCP 支持多种传输方式：
- **stdio**：标准输入输出，适用于本地进程
- **SSE（Server-Sent Events）**：服务器推送事件，适用于 Web 场景

> **比喻**：
> - stdio = 像面对面传纸条
> - SSE = 像打电话实时沟通

### 3.2 MCP Server 必须提供的接口

| 接口 | 作用 | 比喻 |
|------|------|------|
| `tools/list` | 获取 Server 中所有可用的 Tool 列表 | 「你们店有什么菜？」 |
| `tools/call` | 调用指定的 Tool 并返回结果 | 「我要一份宫保鸡丁」 |
| `prompts/list` | 获取可用的 Prompt 模板（可选） | 「有什么套餐推荐？」 |
| `resources/list` | 获取可用资源列表（可选） | 「有什么配料可以加？」 |

### 3.3 MCP 的优势

1. **标准化**：统一的工具描述和调用格式
2. **可复用**：一个 MCP Server 可以被多个 Agent 使用
3. **跨语言**：不限制编程语言，任何语言都能实现 MCP 协议
4. **分布式**：工具可以部署在不同的服务器上

> **比喻**：就像 USB 设备——
> - 一个 U 盘可以插在 Windows、Mac、Linux 上（跨语言）
> - 一个 U 盘可以同时被多台电脑使用（可复用）
> - U 盘可以在云端，也可以在本地（分布式）


# 总结：完整的工作流程

> 🎯 **装修公司比喻**
>
> 想象你要装修房子：
> ```
> 你（用户）
>     ↓ 说「我要装修客厅」
> ┌────────────────────────────────────────────────────────────────┐
> │         Agent（项目经理）                                       │
> │  ┌───────────────────────────────────────────────────────────┐  │
> │  │  1. 了解有哪些工人可用（连接 MCP Servers）              │  │
> │  │  2. 告诉设计师工人列表（构造 System Prompt）            │  │
> │  │  3. 设计师收到你的需求和工人信息                         │  │
> │  └───────────────────────────────────────────────────────────┘  │
> │         │                                                    │
> │         ↓ 设计师说「需要木工做柜子」                          │
> │  ┌───────────────────────────────────────────────────────────┐  │
> │  │  4. 联系木工（通过 MCP 调用工具）                       │  │
> │  │  5. 木工做完柜子，返回结果                              │  │
> │  │  6. 告诉设计师「柜子做好了」，继续下一步                 │  │
> │  │  7. 重复直到装修完成                                     │  │
> │  └───────────────────────────────────────────────────────────┘  │
> │         ↓                                                   │
> └────────────────────────────────────────────────────────────────┘
>     ↓ 「装修完成了！」
> 你
> ```

## 整体架构

```
┌─────────────────────────────────────────────────────────────────────────┐
│                                                                         │
│    用户                                                                  │
│     │                                                                   │
│     │ User Prompt                                                       │
│     ↓                                                                   │
│  ┌────────────────────────────────────────────────────────────────┐    │
│  │         Agent (作为 MCP Client)                                  │    │
│  │  ┌───────────────────────────────────────────────────────────┐  │    │
│  │  │  1. 连接 MCP Servers，获取所有 Tools 信息                   │  │    │
│  │  │  2. 将 Tool 信息转化为 System Prompt 或 Function Calling   │  │    │
│  │  │  3. 发送 System Prompt + User Prompt 给 AI 模型            │  │    │
│  │  └───────────────────────────────────────────────────────────┘  │    │
│  │         │                                                    │    │
│  │         │ AI 响应（文本或工具调用请求）                        │    │
│  │         ↓                                                    │    │
│  │  ┌───────────────────────────────────────────────────────────┐  │    │
│  │  │  如果需要调用工具：                                       │  │    │
│  │  │  4. 解析 AI 返回的工具调用请求                             │  │    │
│  │  │  5. 通过 MCP 协议调用对应的 MCP Server                    │  │    │
│  │  │  6. 将工具执行结果返回给 AI 继续处理                       │  │    │
│  │  │  7. 重复直到 AI 生成最终答案                              │  │    │
│  │  └───────────────────────────────────────────────────────────┘  │    │
│  │         │                                                    │    │
│  │         │ 最终答案                                            │    │
│  │         ↓                                                    │    │
│  └────────────────────────────────────────────────────────────────┘    │
│     │                                                                   │
│     │ 返回结果                                                           │
│     ↓                                                                   │
│    用户                                                                  │
│                                                                         │
│  ┌────────────────────────────────────────────────────────────────┐  │
│  │              MCP Servers (提供各种工具)                         │  │
│  │  ┌──────────────────┐  ┌──────────────────┐  ┌──────────────┐ │  │
│  │  │   Weather MCP    │  │  Filesystem MCP  │  │  GitHub MCP  │ │  │
│  │  │   Server         │  │  Server          │  │  Server      │ │  │
│  │  └──────────────────┘  └──────────────────┘  └──────────────┘ │  │
│  └────────────────────────────────────────────────────────────────┘  │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

## 核心概念关系

> 🎯 **餐厅点餐比喻**
>
> ```
> 你（顾客）
>     ↓ 说「我要一份宫保鸡丁」
> ┌────────────────────────────────────────────────────────────────┐
> │         Prompt（菜单翻译）                                     │
> │         把你的话「宫保鸡丁」翻译成后厨能懂的格式               │
> └────────────────────────────────────────────────────────────────┘
>     ↓ 「炒鸡丁，放花生」
> ┌────────────────────────────────────────────────────────────────┐
> │         Agent（传菜员）                                       │
> │         把单子送到后厨，把菜端到你桌上                       │
> └────────────────────────────────────────────────────────────────┘
>     ↓ 「3 号桌，做宫保鸡丁」
> ┌────────────────────────────────────────────────────────────────┐
> │         Function Calling（标准化点单）                          │
> │         用统一格式：「菜品：宫保鸡丁，桌号：3」                 │
> └────────────────────────────────────────────────────────────────┘
>     ↓ 「给厨师看这个单子」
> ┌────────────────────────────────────────────────────────────────┐
> │         MCP（餐饮联盟标准）                                    │
> │         所有加盟店都用相同的工作流程                             │
> └────────────────────────────────────────────────────────────────┘
>     ↓ 「菜做好了！」
> 你
> ```

| 概念 | 作用层 | 核心作用 | 比喻 |
|------|--------|----------|------|
| **Prompt** | 用户↔AI | 定义对话内容和人设 | 菜单和点餐用语 |
| **Agent** | AI↔Tool | 协调 AI 调用工具 | 传菜员 |
| **Function Calling** | Agent↔AI | 标准化工具调用描述 | 标准点单格式 |
| **MCP** | Agent↔Tool | 标准化工具服务通信 | 餐饮联盟标准 |


# 如何写 Agent 代码（以 Python 为例）

> 🎯 **烹饪比喻**
>
> 写 Agent 代码就像开餐厅：
> - **工具函数** = 准备食材和厨具
> - **API Key** = 餐厅营业执照
> - **Agent 对象** = 雇佣厨师
> - **运行** = 开门营业

## 1. 准备工作

### 1.1 定义工具函数

先写好你的工具函数，最好单独用一个文件存放，便于管理和维护。

> **比喻**：就像把刀、锅、砧板分门别类放好，做饭时方便取用。

```python
# tools.py
def get_weather(city: str) -> str:
    """获取指定城市的天气信息"""
    # 这里调用天气 API
    return f"{city} 的天气是晴天，25℃"

def search_files(query: str) -> list[str]:
    """搜索文件"""
    # 这里实现文件搜索逻辑
    return [f"找到文件: {query}"]
```

### 1.2 配置环境变量

获取大语言模型的 API Key，不要直接写在代码中。使用 `.env` 文件存储敏感信息：

> **比喻**：就像把银行密码写在纸上锁进保险箱，不要写在门口的公告板上。

```bash
# .env
OPENAI_API_KEY=sk-your-api-key-here
```

然后在代码中加载：

```python
from dotenv import load_dotenv
load_dotenv()  # 加载 .env 文件到环境变量
```

## 2. 配置 Agent（使用 Pydantic AI）

> **比喻**：就像雇佣厨师——告诉他用什么设备（模型）、什么风格（系统提示词）、会哪些菜谱（工具）。

```python
from pydantic_ai import Agent, RunContext
from tools import get_weather, search_files

# 创建 Agent 对象
agent = Agent(
    model='openai:gpt-4o',              # 指定模型
    system_prompt='你是一个有用的助手',    # 系统提示词（可选）
    deps_type=dict,                      # 依赖类型（可选）
)

# 注册工具函数
@agent.tool
def weather_tool(ctx: RunContext[dict], city: str) -> str:
    """获取城市天气信息"""
    return get_weather(city)

@agent.tool
def file_search_tool(ctx: RunContext[dict], query: str) -> list[str]:
    """搜索本地文件"""
    return search_files(query)
```

## 3. 运行 Agent

```python
# 主程序
def main():
    # 获取用户输入
    user_input = input("请输入你的问题: ")

    # 运行 Agent（同步方式）
    result = agent.run_sync(user_input)

    # 输出结果
    print(result.data)

    # 查看工具调用历史
    if result.tool_calls:
        print("调用的工具:", result.tool_calls)
```

> **比喻**：就像顾客进店点餐，服务员把单子送到后厨，后厨做好端出来。

## 4. 保持对话上下文

> **比喻**：就像和朋友聊天——
> - 第一次见面：「你好，我是小王」
> - 第二次见面：还记得上次说的，继续聊
> - 记忆 = 消息历史

如果希望 AI 记住之前的对话内容，需要保存消息历史：

```python
# 保存所有消息历史
message_history = []

def chat_loop():
    while True:
        user_input = input("\n你: ")
        if user_input.lower() in ['exit', 'quit']:
            break

        # 将之前的消息历史作为参数传入
        result = agent.run_sync(
            user_input,
            message_history=message_history  # 传递历史消息
        )

        print(f"\nAI: {result.data}")

        # 更新消息历史
        message_history.extend(result.all_messages())
```

## 完整示例

> **比喻**：就像一个完整的餐厅开业流程——
> - 拿到营业执照（加载环境变量）
> - 雇佣厨师（创建 Agent）
> - 告诉厨师菜谱（注册工具）
> - 开门营业（运行主程序）

```python
# main.py
import os
from dotenv import load_dotenv
from pydantic_ai import Agent, RunContext

# 加载环境变量
load_dotenv()

# 创建 Agent
agent = Agent(
    'openai:gpt-4o',
    system_prompt='你是一个有帮助的 AI 助手'
)

# 注册工具
@agent.tool
def calculator(ctx: RunContext[dict], expression: str) -> str:
    """计算数学表达式"""
    try:
        result = eval(expression)
        return f"计算结果: {result}"
    except Exception as e:
        return f"计算错误: {e}"

# 运行
if __name__ == '__main__':
    while True:
        user_input = input("\n你: ")
        if user_input == 'exit':
            break

        result = agent.run_sync(user_input)
        print(f"\nAI: {result.data}")
```

---

> 💡 **一句话总结：Prompt + Agent + Function Calling + MCP = 能说能做的 AI！**
>
> - **Prompt** = 让 AI 会说话（有人设）
> - **Agent** = 让 AI 能动手（有工具）
> - **Function Calling** = 让 AI 动手有规范（标准化）
> - **MCP** = 让工具可以随意换（通用接口）
>
> 就像从「只会聊天」升级到「全能管家」！

